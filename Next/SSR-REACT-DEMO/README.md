# 了解ssr本质

**使用express来实现ssr**

- ssr实现需要两个入口文件：
  - 服务端的入口文件server，通过ReactDOMServer.renderToString方法生成一个静态的html页面，但不会处理添加在元素上的任何事件，这时候的web只能实现简单的信息展示，要使web有交互性，客户端需要再用 js 去操作 dom 或者渲染其他动态的部分。就需要注水。
  - 前端的入口文件client，通过ReactDom.hydrate进行注水。
  - 同构渲染： 所谓同构，通俗的讲，就是一套React代码在服务器上运行一遍，到达浏览器又运行一遍。服务端渲染完成页面结构，客户端渲染绑定事件。它是在SPA的基础上，利用服务端渲染直出首屏，解除单页面应用在首屏渲染上面临的窘境。

### 回顾
1. 什么是同构渲染？
  - 同构渲染其实就是将同一套react代码在服务端执行一遍渲染静态页面，又在客户端执行一遍完成事件绑定。
2. 为什么react需要在服务端执行一遍，又在客户端执行一遍?/为什么服务端渲染完成的页面结构事件绑定无效？
  - 原因很简单，服务端使用 renderToString 渲染页面，而 react-dom/server 下的 renderToString 并没有做事件相关的处理，因此返回给浏览器的内容不会有事件绑定，渲染出来的页面只是一个静态的 HTML 页面。只有在客户端渲染 React 组件并初始化 React 实例后，才能更新组件的 state 和 props，初始化 React 的事件系统，执行虚拟 DOM 的重新渲染机制，让 React 组件真正“ 动” 起来。
3. 服务器端已经渲染了一次 React 组件，如果在客户端中再渲染一次 React 组件，会不会渲染两次 React 组件？
  - 答案是不会的。秘诀在于 data-react-checksum 属性，上文有说过，如果使用 renderToString 渲染组件，会在组件的第一个 DOM 带有 data-react-checksum 属性，这个属性是通过 adler32 算法算出来：如果两个组件有相同的 props 和 DOM 结构时，adler32 算法算出的 checksum 值会一样，有点类似于哈希算法。所以当客户端渲染 React 组件时，首先计算出组件的 checksum 值，然后检索 HTML DOM 看看是否存在数值相同的data-react-checksum属性，如果存在，则组件只会渲染一次，如果不存在，则会抛出一个 warning 异常。也就是说，当服务器端和客户端渲染具有相同的 props 和相同 DOM 结构的组件时，该 React 组件只会渲染一次。在客户端进行渲染时，会检查 HTML DOM 是否存在相同的 data-react-checksum，如果一致，则客户端可以直接使用服务端生成的 DOM 树，不会重复渲染。如果不一致，则客户端会重新渲染整个HTML。这样就使得服务端渲染的视图和客户端渲染的视图保持一致。
  - 只有首屏是服务端渲染（目的：加快首屏渲染，优化SEO），之后的页面跳转通过前端路由进行，遵循SPA（目的：支持局部刷新，前后端分离，减轻服务器压力。
5. 同构应用带来的问题?上面只讲了同构渲染的优点，但其实同构渲染的引发的问题也不少，比如：
  - 不能在服务端渲染期间操作  DOM、BOM api，比如 document、window对象等，应尽量避免在首屏逻辑使用到它们增加了代码的复杂度，某些代码操作需要区分运行环境要注意不打包只在服务端运行的外部扩展库，否则会造成构建后的文件体积过大
6. 同构应用使用建议
  - 首屏渲染速度是否真的重要
  - SEO是否真的需要

## store 注水
  - 每个组件 绑定类似getSideServerProps方法，在请求资源时候调用，并更新store中数据，并在script标签下绑定到window上。在client时候获取该window上属性，并初始下store